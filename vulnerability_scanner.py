"""
DinoAir Security Vulnerability Scanner.

This module provides automated vulnerability scanning specifically for DinoAir,
focusing on common web application and API vulnerabilities.
"""

import asyncio
import json
import time
from dataclasses import dataclass
from enum import Enum
from typing import Any, Dict, List, Optional
from urllib.parse import quote

import requests


class VulnerabilityType(Enum):
    """Types of vulnerabilities to scan for."""

    SQL_INJECTION = "sql_injection"
    XSS = "cross_site_scripting"
    COMMAND_INJECTION = "command_injection"
    PATH_TRAVERSAL = "path_traversal"
    INSECURE_DIRECT_OBJECT_REFERENCE = "idor"
    SECURITY_MISCONFIGURATION = "security_misconfiguration"
    SENSITIVE_DATA_EXPOSURE = "sensitive_data_exposure"
    BROKEN_AUTHENTICATION = "broken_authentication"
    BROKEN_ACCESS_CONTROL = "broken_access_control"
    INSUFFICIENT_LOGGING = "insufficient_logging"


@dataclass
class VulnerabilityFinding:
    """A vulnerability finding."""

    vuln_type: VulnerabilityType
    severity: str  # critical, high, medium, low
    endpoint: str
    method: str
    payload: str
    response_code: int
    evidence: str
    recommendation: str
    cwe_id: Optional[str] = None


class DinoAirVulnerabilityScanner:
    """Vulnerability scanner specifically for DinoAir."""

    def __init__(self, base_url: str = "http://127.0.0.1:24801"):
        self.base_url = base_url.rstrip("/")
        self.session = requests.Session()
        self.findings: List[VulnerabilityFinding] = []

        # Common headers for testing
        self.session.headers.update(
            {
                "User-Agent": "DinoAir-VulnScanner/1.0",
                "Accept": "application/json, text/html, */*",
                "Accept-Language": "en-US,en;q=0.9",
            }
        )

    async def run_comprehensive_scan(self) -> List[VulnerabilityFinding]:
        """Run comprehensive vulnerability scan."""

        print("ğŸ” Starting DinoAir Vulnerability Scan...")
        print(f"Target: {self.base_url}")

        # Phase 1: Discovery
        print("\nğŸ“¡ Phase 1: Endpoint Discovery")
        endpoints = await self._discover_endpoints()
        print(f"   Found {len(endpoints)} endpoints")

        # Phase 2: SQL Injection Testing
        print("\nğŸ’‰ Phase 2: SQL Injection Testing")
        await self._test_sql_injection(endpoints)

        # Phase 3: XSS Testing
        print("\nğŸ•·ï¸ Phase 3: Cross-Site Scripting Testing")
        await self._test_xss_vulnerabilities(endpoints)

        # Phase 4: Command Injection Testing
        print("\nâš¡ Phase 4: Command Injection Testing")
        await self._test_command_injection(endpoints)

        # Phase 5: Path Traversal Testing
        print("\nğŸ“‚ Phase 5: Path Traversal Testing")
        await self._test_path_traversal(endpoints)

        # Phase 6: IDOR Testing
        print("\nğŸ” Phase 6: Insecure Direct Object Reference Testing")
        await self._test_idor_vulnerabilities(endpoints)

        # Phase 7: Security Misconfiguration
        print("\nâš™ï¸ Phase 7: Security Misconfiguration Testing")
        await self._test_security_misconfigurations()

        # Phase 8: Authentication Testing
        print("\nğŸ”‘ Phase 8: Authentication Vulnerability Testing")
        await self._test_authentication_vulnerabilities()

        # Phase 9: Access Control Testing
        print("\nğŸšª Phase 9: Access Control Testing")
        await self._test_access_control_issues()

        print(
            f"\nâœ… Vulnerability scan complete! Found {len(self.findings)} issues")
        return self.findings

    async def _discover_endpoints(self) -> List[str]:
        """Discover available endpoints."""

        endpoints = []

        # Common API endpoints for DinoAir
        common_paths = [
            "/",
            "/health",
            "/docs",
            "/openapi.json",
            "/api",
            "/api/v1",
            "/api/v1/health",
            "/api/v1/notes",
            "/api/v1/projects",
            "/api/v1/artifacts",
            "/api/v1/search",
            "/api/v1/files",
            "/api/v1/upload",
            "/api/v1/download",
            "/api/v1/export",
            "/api/v1/import",
            "/api/v1/backup",
            "/api/v1/restore",
            "/api/v1/config",
            "/api/v1/users",
            "/api/v1/auth",
            "/api/v1/auth/login",
            "/api/v1/auth/logout",
            "/api/v1/auth/register",
            "/api/v1/auth/reset",
            "/api/v1/admin",
            "/api/v1/admin/users",
            "/api/v1/admin/logs",
            "/api/v1/admin/metrics",
            "/rag/ingest",
            "/rag/ingest/files",
            "/rag/query",
            "/static",
            "/uploads",
            "/downloads",
            "/logs",
            "/metrics",
            "/status",
            "/version",
        ]

        for path in common_paths:
            try:
                response = self.session.get(
                    f"{self.base_url}{path}", timeout=5, allow_redirects=False
                )

                # Consider endpoint found if it doesn't return 404
                if response.status_code != 404:
                    endpoints.append(path)
                    print(
                        f"   ğŸ“ Found: {path} (Status: {response.status_code})")

            except Exception:
                pass  # Endpoint not reachable

        return endpoints

    async def _test_sql_injection(self, endpoints: List[str]) -> None:
        """Test for SQL injection vulnerabilities."""

        # SQL injection payloads
        sql_payloads = [
            "' OR '1'='1",
            "' OR '1'='1' --",
            "' OR '1'='1' /*",
            "'; DROP TABLE users; --",
            "' UNION SELECT null,null,null--",
            "admin'--",
            "admin' #",
            "admin'/*",
            "' or 1=1#",
            "' or 1=1--",
            "' or 1=1/*",
            "') or ('1'='1--",
            "') or ('1'='1#",
            "') or ('1'='1/*",
            "1' ORDER BY 1--",
            "1' ORDER BY 2--",
            "1' ORDER BY 3--",
            "1' GROUP BY 1--",
            "1' GROUP BY 2--",
            "1' GROUP BY 3--",
            "' AND (SELECT COUNT(*) FROM information_schema.tables)>0--",
        ]

        # Parameters to test
        test_params = [
            "id",
            "user_id",
            "note_id",
            "project_id",
            "search",
            "q",
            "query",
            "name",
            "email",
        ]

        for endpoint in endpoints:
            for param in test_params:
                for payload in sql_payloads:
                    try:
                        # Test GET parameter
                        url = (
                            f"{self.base_url}{endpoint}"
                            f"?{param}={quote(payload)}"
                        )
                        response = self.session.get(url, timeout=5)

                        if self._detect_sql_injection(response, payload):
                            self.findings.append(
                                VulnerabilityFinding(
                                    vuln_type=VulnerabilityType.SQL_INJECTION,
                                    severity="high",
                                    endpoint=endpoint,
                                    method="GET",
                                    payload=f"{param}={payload}",
                                    response_code=response.status_code,
                                    evidence=response.text[:500],
                                    recommendation="Use parameterized queries and input validation",
                                    cwe_id="CWE-89",
                                )
                            )
                            print(
                                f"   ğŸš¨ SQL Injection found: {endpoint}?{param}={payload[:20]}..."
                            )

                        # Test POST data
                        if endpoint.startswith("/api/"):
                            post_data = {param: payload}
                            response = self.session.post(
                                f"{self.base_url}{endpoint}",
                                json=post_data,
                                timeout=5,
                            )

                            if self._detect_sql_injection(response, payload):
                                self.findings.append(
                                    VulnerabilityFinding(
                                        vuln_type=VulnerabilityType.SQL_INJECTION,
                                        severity="high",
                                        endpoint=endpoint,
                                        method="POST",
                                        payload=json.dumps(post_data),
                                        response_code=response.status_code,
                                        evidence=response.text[:500],
                                        recommendation="Use parameterized queries and input validation",
                                        cwe_id="CWE-89",
                                    )
                                )
                                print(
                                    f"   ğŸš¨ SQL Injection found: POST {endpoint}"
                                )

                    except Exception:
                        pass

    @staticmethod
    def _detect_sql_injection(response: requests.Response, payload: str) -> bool:
        """Detect if response indicates SQL injection vulnerability."""

        response_text = response.text.lower()

        # SQL error patterns
        sql_errors = [
            "sql syntax",
            "mysql_fetch",
            "ora-01756",
            "microsoft ole db provider for odbc drivers",
            "unclosed quotation mark after the character string",
            "quoted string not properly terminated",
            "sqlexception",
            "postgresql",
            "warning: mysql",
            "warning: pg_",
            "valid mysql result",
            "warning: oci_",
            "microsoft access driver",
            "ole/db provider returned message",
            "sqlite_exception",
            "sqlite3.operationalerror",
            "database error",
            "sql command not properly ended",
            "constraint violation",
            "invalid column name",
            "table doesn't exist",
            "column count doesn't match",
            "sqlstate",
            "syntax error",
        ]

        # Time-based detection
        if "' AND SLEEP(" in payload.upper() or "' WAITFOR DELAY" in payload.upper():
            # For time-based, we'd need to measure response time
            if response.elapsed.total_seconds() > 5:
                return True

        # Check for SQL errors in response
        for error in sql_errors:
            if error in response_text:
                return True

        # Check for boolean-based injection
        if "or '1'='1" in payload.lower():
            # Look for differences in response that might indicate successful injection
            if len(response.text) > 0 and response.status_code == 200:
                # This is a basic check - in practice you'd compare with a baseline
                return False  # Would need baseline comparison

        return False

    async def _test_xss_vulnerabilities(self, endpoints: List[str]) -> None:
        """Test for XSS vulnerabilities."""

        xss_payloads = [
            "<script>alert('XSS')</script>",
            "<img src=x onerror=alert('XSS')>",
            "<svg onload=alert('XSS')>",
            "javascript:alert('XSS')",
            "';alert('XSS');//",
            "\"><script>alert('XSS')</script>",
            "<iframe src=javascript:alert('XSS')>",
            "<body onload=alert('XSS')>",
            "<input autofocus onfocus=alert('XSS')>",
            "<select onfocus=alert('XSS') autofocus>",
            "<textarea onfocus=alert('XSS') autofocus>",
            "<keygen onfocus=alert('XSS') autofocus>",
            "<video><source onerror=alert('XSS')>",
            "<audio src=x onerror=alert('XSS')>",
            "<details open ontoggle=alert('XSS')>",
            "<marquee onstart=alert('XSS')>",
        ]

        test_params = ["q", "search", "query", "name",
                       "message", "content", "comment", "title"]

        for endpoint in endpoints:
            for param in test_params:
                for payload in xss_payloads:
                    try:
                        # Test GET parameter
                        url = (
                            f"{self.base_url}{endpoint}"
                            f"?{param}={quote(payload)}"
                        )
                        response = self.session.get(url, timeout=5)

                        if self._detect_xss(response, payload):
                            self.findings.append(
                                VulnerabilityFinding(
                                    vuln_type=VulnerabilityType.XSS,
                                    severity="medium",
                                    endpoint=endpoint,
                                    method="GET",
                                    payload=f"{param}={payload}",
                                    response_code=response.status_code,
                                    evidence=response.text[:500],
                                    recommendation=(
                                        "Implement proper output encoding and "
                                        "CSP"
                                    ),
                                    cwe_id="CWE-79",
                                )
                            )
                            print(
                                f"   ğŸ•·ï¸ XSS found: {endpoint}"
                                f"?{param}={payload[:20]}..."
                            )

                    except Exception:
                        pass

    @staticmethod
    def _detect_xss(response: requests.Response, payload: str) -> bool:
        """Detect if response indicates XSS vulnerability."""

        # Check if payload is reflected in response without proper encoding
        response_text = response.text

        # Look for unencoded script tags or javascript
        dangerous_patterns = [
            "<script",
            "javascript:",
            "onload=",
            "onerror=",
            "onfocus=",
            "onclick=",
            "onmouseover=",
        ]

        for pattern in dangerous_patterns:
            if pattern in payload.lower() and pattern in response_text.lower():
                return True

        return False

    async def _test_command_injection(self, endpoints: List[str]) -> None:
        """Test for command injection vulnerabilities."""

        # Command injection payloads for different OS
        cmd_payloads = [
            "; ls -la",
            "| whoami",
            "& dir",
            "; cat /etc/passwd",
            "| type C:\\Windows\\System32\\drivers\\etc\\hosts",
            "; ping -c 1 127.0.0.1",
            "| ping -n 1 127.0.0.1",
            "; id",
            "& whoami",
            "| id",
            "; uname -a",
            "& systeminfo",
            "`whoami`",
            "$(whoami)",
            "${whoami}",
            "; sleep 5",
            "| timeout 5",
        ]

        test_params = ["cmd", "command", "exec",
                       "system", "filename", "file", "path"]

        for endpoint in endpoints:
            for param in test_params:
                for payload in cmd_payloads:
                    try:
                        url = (
                            f"{self.base_url}{endpoint}?"
                            f"{param}={quote(payload)}"
                        )
                        start_time = time.time()
                        response = self.session.get(url, timeout=10)
                        response_time = time.time() - start_time

                        if self._detect_command_injection(response, payload, response_time):
                            self.findings.append(
                                VulnerabilityFinding(
                                    vuln_type=VulnerabilityType.COMMAND_INJECTION,
                                    severity="critical",
                                    endpoint=endpoint,
                                    method="GET",
                                    payload=f"{param}={payload}",
                                    response_code=response.status_code,
                                    evidence=response.text[:500],
                                    recommendation="Use parameterized commands and input validation",
                                    cwe_id="CWE-78",
                                )
                            )
                            print(
                                f"   âš¡ Command Injection found: {endpoint}?"
                                f"{param}={payload[:20]}..."
                            )

                    except Exception:
                        pass

    @staticmethod
    def _detect_command_injection(response: requests.Response, payload: str, response_time: float) -> bool:
        """Detect command injection vulnerability."""

        response_text = response.text.lower()

        # Command output indicators
        cmd_indicators = [
            "uid=",
            "gid=",
            "groups=",
            "root:",
            "administrator",
            "volume serial number",
            "directory of",
            "total ",
            "drwx",
            "-rw-",
            "windows\\system32",
            "c:\\windows",
            "/bin/",
            "/usr/",
            "/etc/",
            "pong",  # from ping commands
            "reply from",
        ]

        for indicator in cmd_indicators:
            if indicator in response_text:
                return True

        # Time-based detection for sleep commands
        if "sleep" in payload.lower() and response_time > 4:
            return True

        return False

    async def _test_path_traversal(self, endpoints: List[str]) -> None:
        """Test for path traversal vulnerabilities."""

        path_payloads = [
            "../../../etc/passwd",
            "..\\..\\..\\windows\\system32\\drivers\\etc\\hosts",
            "....//....//....//etc/passwd",
            "%2e%2e%2f%2e%2e%2f%2e%2e%2fetc%2fpasswd",
            "..%252f..%252f..%252fetc%252fpasswd",
            "..%c0%af..%c0%af..%c0%afetc%c0%afpasswd",
            "/etc/passwd",
            "C:\\Windows\\System32\\drivers\\etc\\hosts",
            "/proc/version",
            "/proc/self/environ",
            "../../../../../../../etc/passwd%00",
            "..\\..\\..\\..\\..\\..\\windows\\win.ini",
        ]

        test_params = [
            "file",
            "filename",
            "path",
            "page",
            "doc",
            "document",
            "include",
        ]

        for endpoint in endpoints:
            for param in test_params:
                for payload in path_payloads:
                    try:
                        url = f"{self.base_url}{endpoint}?{param}={quote(payload)}"
                        response = self.session.get(url, timeout=5)

                        if self._detect_path_traversal(response, payload):
                            self.findings.append(
                                VulnerabilityFinding(
                                    vuln_type=VulnerabilityType.PATH_TRAVERSAL,
                                    severity="high",
                                    endpoint=endpoint,
                                    method="GET",
                                    payload=f"{param}={payload}",
                                    response_code=response.status_code,
                                    evidence=response.text[:500],
                                    recommendation="Implement proper path validation and sanitization",
                                    cwe_id="CWE-22",
                                )
                            )
                            print(
                                f"   ğŸ“‚ Path Traversal found: "
                                f"{endpoint}?{param}={payload[:30]}..."
                            )

                    except Exception:
                        pass

    @staticmethod
    def _detect_path_traversal(response: requests.Response, payload: str) -> bool:
        """Detect path traversal vulnerability."""

        response_text = response.text.lower()

        # File content indicators
        file_indicators = [
            "root:x:",
            "[boot loader]",
            "127.0.0.1",
            "localhost",
            "# copyright",
            "# hosts file",
            "mozilla/",
            "microsoft",
            "version ",
            "path=",
            "windir=",
            "program files",
        ]

        for indicator in file_indicators:
            if indicator in response_text:
                return True

        return False

    async def _test_idor_vulnerabilities(self, endpoints: List[str]) -> None:
        """Test for Insecure Direct Object Reference vulnerabilities."""

        # Test different ID formats
        test_ids = [
            "1",
            "2",
            "3",
            "100",
            "999",
            "1000",
            "admin",
            "test",
            "guest",
            "user",
            "00000001",
            "00000002",
            "uuid-1234",
            "abc-123",
        ]

        id_params = ["id", "user_id", "note_id",
                     "project_id", "file_id", "doc_id"]

        for endpoint in endpoints:
            for param in id_params:
                responses = {}

                for test_id in test_ids:
                    try:
                        url = f"{self.base_url}{endpoint}?{param}={test_id}"
                        response = self.session.get(url, timeout=5)

                        if response.status_code == 200:
                            responses[test_id] = {
                                "status": response.status_code,
                                "length": len(response.text),
                                "content": response.text[:200],
                            }

                    except Exception:
                        pass

                # Analyze responses for IDOR
                if self._detect_idor(responses):
                    self.findings.append(
                        VulnerabilityFinding(
                            vuln_type=(
                                VulnerabilityType.
                                INSECURE_DIRECT_OBJECT_REFERENCE
                            ),
                            severity="medium",
                            endpoint=endpoint,
                            method="GET",
                            payload=f"{param}=[various_ids]",
                            response_code=200,
                            evidence=(
                                f"Different responses for different IDs: "
                                f"{list(responses.keys())}"
                            ),
                            recommendation="Implement proper authorization checks",
                            cwe_id="CWE-639",
                        )
                    )
                    print(f"   ğŸ” IDOR found: {endpoint}?{param}=...")

    @staticmethod
    def _detect_idor(responses: Dict[str, Dict]) -> bool:
        """Detect IDOR vulnerability by analyzing responses."""

        if len(responses) < 2:
            return False

        # Check if we get different valid responses for different IDs
        valid_responses = [r for r in responses.values() if r["status"] == 200]

        if len(valid_responses) >= 2:
            # Check if content lengths are significantly different
            lengths = [r["length"] for r in valid_responses]
            if max(lengths) - min(lengths) > 100:  # Significant difference
                return True

        return False

    async def _test_security_misconfigurations(self) -> None:
        """Test for security misconfigurations."""

        # Test for exposed sensitive files
        sensitive_files = [
            "/.env",
            "/.git/config",
            "/config.json",
            "/config.yaml",
            "/backup.sql",
            "/database.db",
            "/app.log",
            "/error.log",
            "/admin.log",
            "/web.config",
            "/robots.txt",
            "/.htaccess",
            "/phpinfo.php",
            "/server-status",
            "/server-info",
        ]

        for file_path in sensitive_files:
            try:
                response = self.session.get(
                    f"{self.base_url}{file_path}", timeout=5)

                if response.status_code == 200:
                    self.findings.append(
                        VulnerabilityFinding(
                            vuln_type=VulnerabilityType.SENSITIVE_DATA_EXPOSURE,
                            severity="medium",
                            endpoint=file_path,
                            method="GET",
                            payload="N/A",
                            response_code=response.status_code,
                            evidence=response.text[:200],
                            recommendation=f"Remove or protect {file_path}",
                            cwe_id="CWE-200",
                        )
                    )
                    print(f"   âš™ï¸ Exposed file: {file_path}")

            except Exception:
                pass

        # Test for debug/error information disclosure
        debug_endpoints = [
            "/debug",
            "/trace",
            "/error",
            "/exception",
            "/stack",
            "/phpinfo",
            "/info",
        ]

        for endpoint in debug_endpoints:
            try:
                response = self.session.get(
                    f"{self.base_url}{endpoint}", timeout=5)

                if response.status_code == 200 and len(response.text) > 100:
                    self.findings.append(
                        VulnerabilityFinding(
                            vuln_type=VulnerabilityType.SECURITY_MISCONFIGURATION,
                            severity="low",
                            endpoint=endpoint,
                            method="GET",
                            payload="N/A",
                            response_code=response.status_code,
                            evidence=response.text[:200],
                            recommendation=f"Disable debug endpoint {endpoint}",
                            cwe_id="CWE-200",
                        )
                    )
                    print(f"   âš™ï¸ Debug endpoint exposed: {endpoint}")

            except Exception:
                pass

    async def _test_authentication_vulnerabilities(self) -> None:
        """Test for authentication vulnerabilities."""

        # Test default credentials
        default_creds = [
            ("admin", "admin"),
            ("admin", "password"),
            ("admin", "123456"),
            ("administrator", "administrator"),
            ("root", "root"),
            ("test", "test"),
            ("guest", "guest"),
            ("user", "user"),
        ]

        auth_endpoints = ["/api/v1/auth/login", "/auth/login", "/login"]

        for endpoint in auth_endpoints:
            for username, password in default_creds:
                try:
                    auth_data = {"username": username, "password": password}

                    response = self.session.post(
                        f"{self.base_url}{endpoint}", json=auth_data, timeout=5
                    )

                    if response.status_code == 200:
                        self.findings.append(
                            VulnerabilityFinding(
                                vuln_type=VulnerabilityType.BROKEN_AUTHENTICATION,
                                severity="critical",
                                endpoint=endpoint,
                                method="POST",
                                payload=f"username={username}, password={password}",
                                response_code=response.status_code,
                                evidence=response.text[:200],
                                recommendation="Change default credentials immediately",
                                cwe_id="CWE-521",
                            )
                        )
                        print(
                            f"   ğŸ”‘ Default credentials work: {username}:{password}")

                except Exception:
                    pass

    async def _test_access_control_issues(self) -> None:
        """Test for access control issues."""

        # Test administrative endpoints without authentication
        admin_endpoints = [
            "/api/v1/admin",
            "/api/v1/admin/users",
            "/api/v1/admin/logs",
            "/api/v1/admin/config",
            "/admin",
            "/admin/users",
            "/admin/config",
            "/management",
            "/control",
        ]

        for endpoint in admin_endpoints:
            try:
                response = self.session.get(
                    f"{self.base_url}{endpoint}", timeout=5)

                if response.status_code == 200:
                    self.findings.append(
                        VulnerabilityFinding(
                            vuln_type=VulnerabilityType.BROKEN_ACCESS_CONTROL,
                            severity="high",
                            endpoint=endpoint,
                            method="GET",
                            payload="N/A",
                            response_code=response.status_code,
                            evidence=response.text[:200],
                            recommendation="Implement proper access controls",
                            cwe_id="CWE-284",
                        )
                    )
                    print(f"   ğŸšª Unprotected admin endpoint: {endpoint}")

            except Exception:
                pass

    def generate_report(self) -> Dict[str, Any]:
        """Generate vulnerability report."""

        # Categorize findings by severity
        severity_counts = {"critical": 0, "high": 0, "medium": 0, "low": 0}
        findings_by_type = {}

        for finding in self.findings:
            severity_counts[finding.severity] += 1

            if finding.vuln_type not in findings_by_type:
                findings_by_type[finding.vuln_type] = []
            findings_by_type[finding.vuln_type].append(finding)

        # Calculate risk score
        risk_score = (
            severity_counts["critical"] * 10
            + severity_counts["high"] * 7
            + severity_counts["medium"] * 4
            + severity_counts["low"] * 1
        )

        return {
            "summary": {
                "total_findings": len(self.findings),
                "risk_score": risk_score,
                "severity_breakdown": severity_counts,
                "scan_timestamp": time.time(),
            },
            "findings_by_type": {
                vuln_type.value: [
                    {
                        "severity": f.severity,
                        "endpoint": f.endpoint,
                        "method": f.method,
                        "payload": f.payload,
                        "evidence": (
                            f.evidence[:100] +
                            "..." if len(f.evidence) > 100 else f.evidence
                        ),
                        "recommendation": f.recommendation,
                        "cwe_id": f.cwe_id,
                    }
                    for f in findings
                ]
                for vuln_type, findings in findings_by_type.items()
            },
            "recommendations": DinoAirVulnerabilityScanner._generate_recommendations(severity_counts),
        }

    @staticmethod
    def _generate_recommendations(severity_counts: Dict[str, int]) -> List[str]:
        """Generate recommendations based on findings."""
        recommendations = []

        if severity_counts["critical"] > 0:
            recommendations.append(
                "ğŸš¨ CRITICAL: Address critical vulnerabilities immediately")
            recommendations.append(
                "ğŸ” Implement strong authentication and access controls")

        if severity_counts["high"] > 0:
            recommendations.append(
                "âš ï¸ HIGH: Fix high-severity vulnerabilities within 24 hours")
            recommendations.append(
                "ğŸ›¡ï¸ Implement input validation and output encoding")

        if severity_counts["medium"] > 0:
            recommendations.append(
                "ğŸ“‹ MEDIUM: Address medium-severity issues within a week")
            recommendations.append(
                "ğŸ” Regular security testing and code review")

        if severity_counts["low"] > 0:
            recommendations.append("ğŸ“ LOW: Plan to fix low-severity issues")
            recommendations.append("ğŸ“š Security awareness and training")

        recommendations.extend(
            [
                "ğŸ”„ Implement regular vulnerability scanning",
                "ğŸ“Š Set up security monitoring and logging",
                "ğŸ› ï¸ Use secure coding practices",
                "ğŸ§ª Perform penetration testing regularly",
            ]
        )

        return recommendations


async def run_vulnerability_scan(
    target_url: str = "http://127.0.0.1:24801",
) -> Dict[str, Any]:
    """Run vulnerability scan against DinoAir."""

    scanner = DinoAirVulnerabilityScanner(target_url)
    await scanner.run_comprehensive_scan()
    report = scanner.generate_report()

    return report

if __name__ == "__main__":
    # Run vulnerability scan
    async def main():
        """
        Main CLI entry point for the DinoAir vulnerability scanner.
        Performs health checks, runs scans, and saves and displays results.
        """
        print("ğŸ” DinoAir Vulnerability Scanner")
        print("=" * 50)

        # Check if target is reachable
        try:
            response = requests.get("http://127.0.0.1:24801/health", timeout=5)
            print(f"âœ… Target is reachable (Status: {response.status_code})")
        except Exception as e:
            print(f"âŒ Target unreachable: {e}")
            print("ğŸ’¡ Start your DinoAir server first!")
            return

        # Run scan
        report = await run_vulnerability_scan()

        # Display results
        summary = report["summary"]
        print("\nğŸ“Š VULNERABILITY SCAN RESULTS")
        print(f"Total Findings: {summary['total_findings']}")
        print(f"Risk Score: {summary['risk_score']}")
        print(f"Critical: {summary['severity_breakdown']['critical']}")
        print(f"High: {summary['severity_breakdown']['high']}")
        print(f"Medium: {summary['severity_breakdown']['medium']}")
        print(f"Low: {summary['severity_breakdown']['low']}")

        # Show top recommendations
        print("\nğŸ“‹ TOP RECOMMENDATIONS:")
        for rec in report["recommendations"][:5]:
            print(f"   {rec}")

        # Save report
        with open("vulnerability_report.json", "w") as f:
            json.dump(report, f, indent=2)

        print("\nğŸ’¾ Detailed report saved to: vulnerability_report.json")

    asyncio.run(main())
